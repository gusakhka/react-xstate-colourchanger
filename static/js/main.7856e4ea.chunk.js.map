{"version":3,"sources":["dmAppointmentPlus.ts","index.tsx"],"names":["say","text","send","_context","type","value","grammar","person","day","time","BooleanGrammar","clarity","dmMachine","initial","id","states","begin","hist","init","on","CLICK","welcome","ENDSPEECH","prompt","entry","who","RECOGNISED","target","cond","context","recResult","actions","assign","MAXSPEECH","counts","ask","delay","nomatch","timeoutnomatch","wholeday","wholeday_is_confirmed","Determination_time","confirm_time","create_appointment","maxtimeout","help","cancel","inspect","url","iframe","machine","Machine","dm","asrtts","idle","LISTEN","SPEAK","event","ttsAgenda","recognising","exit","ASRRESULT","match","speaking","recLogResult","console","log","test","logIntent","nluData","intent","name","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","result","listen","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","changeColour","document","body","background","ttsStart","effect","ttsCancel","current","onClick","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.7856e4ea.chunk.js","sourcesContent":["import { MachineConfig, send, Action, assign } from \"xstate\";\r\nimport { dmMkapp } from \"./mkapp\";\r\n\r\n\r\n\r\nexport function say(text: string): Action<SDSContext, SDSEvent> {\r\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\r\n}\r\n\r\nexport function listen(): Action<SDSContext, SDSEvent> {\r\n    return send('LISTEN')\r\n}\r\n\r\nconst grammar: { [index: string]: { person?: string, day?: string, time?: string } } = {\r\n    //PERSON\r\n    \"John\": { person: \"John Appleseed\" },\r\n    \"Olivia\": { person: \"Olivia Smith\" },\r\n    \"Daniel\": { person: \"Daniel Jones\" },\r\n    \"James\": { person: \"James Williams\" },\r\n    \"Mia\": { person: \"Mia Wilson\" },\r\n    \"Jack\": { person: \"Jack Evans\" },\r\n    \"Emily\": { person: \"Emily Thomas\" },\r\n    \r\n    //DAYS\r\n    \"on Monday\": { day: \"Monday\" },\r\n    \"Monday\": { day: \"Monday\" },\r\n    \"on Tuesday\": { day: \"Tuesda\" },\r\n    \"Tuesday\": { day: \"Tuesda\" },\r\n    \"on Wednesday\": { day: \"Wednesday\" },\r\n    \"Wednesday\": { day: \"Wednesday\" },\r\n    \"on Thursday\": { day: \"Thursday\" },\r\n    \"Thursday\": { day: \"Thursday\" },\r\n    \"on Friday\": { day: \"Friday\" },\r\n    \"Friday\": { day: \"Friday\" },\r\n    \"on Saturday\": { day: \"Saturday\" },\r\n    \"Saturday\": { day: \"Saturday\" },\r\n    \"on Sunday\": { day: \"Sunday\" },\r\n    \"Sunday\": { day: \"Sunday\" },\r\n\r\n    //TIMES\r\n    \"at 1\": { time: \"01:00\" },\r\n    \"1\": { time: \"01:00\" },\r\n    \"at 2\": { time: \"02:00\" },\r\n    \"2\": { time: \"02:00\" },\r\n    \"at 3\": { time: \"03:00\" },\r\n    \"t3\": { time: \"03:00\" },\r\n    \"at 4\": { time: \"04:00\" },\r\n    \"4\": { time: \"04:00\" },\r\n    \"at 5\": { time: \"05:00\" },\r\n    \"5\": { time: \"05:00\" },\r\n    \"at 6\": { time: \"06:00\" },\r\n    \"6\": { time: \"06:00\" },\r\n    \"at 7\": { time: \"07:00\" },\r\n    \"7\": { time: \"07:00\" },\r\n    \"at 8\": { time: \"08:00\" },\r\n    \"8\": { time: \"08:00\" },\r\n    \"at 9\": { time: \"09:00\" },\r\n    \"9\": { time: \"09:00\" },\r\n    \"at 10\": { time: \"10:00\" },\r\n    \"10\": { time: \"10:00\" },\r\n    \"at 11\": { time: \"11:00\" },\r\n    \"11\": { time: \"11:00\" },\r\n    \"at 12\": { time: \"12:00\" },\r\n    \"12\": { time: \"12:00\" }\r\n}\r\n\r\nconst BooleanGrammar: { [index: string]: { clarity?: boolean } } = {\r\n    //TRUE\r\n    \"yes\": { clarity: true },\r\n    \"of course\": { clarity: true },\r\n    \"alright\": { clarity: true },\r\n    \"very well\": { clarity: true },\r\n    \"sure\": { clarity: true },\r\n    \"agreed\": { clarity: true },\r\n    \"absolutely\": { clarity: true },\r\n    \"surely\": { clarity: true },\r\n    //FALSE\r\n    \"no\": { clarity: false },\r\n    \"nope\": { clarity: false },\r\n    \"nah\": { clarity: false },\r\n    \"negative\": { clarity: false },\r\n    \"no indeed\": { clarity: false },\r\n    \"no thanks\": { clarity: false },\r\n    \"not at all\": { clarity: false }\r\n\r\n}\r\n\r\n\r\n\r\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'begin',\r\n    id: \"appointment\",\r\n    states: {\r\n        begin: {\r\n            initial: \"init\",\r\n            states: {\r\n                hist: { type: 'history' },\r\n                init: {\r\n                    on: {\r\n                        CLICK: 'welcome'\r\n                    }\r\n                },\r\n                welcome: {\r\n                    initial: \"prompt\",\r\n                    on: { ENDSPEECH: \"who\" },\r\n                    states: {\r\n                        prompt: { entry: say(\"Let's create an appointment\") }\r\n                    }\r\n                },\r\n                who: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [\r\n                            {target: \"#root.dm.help\",cond: (context) => context.recResult === 'help'},\r\n                            {cond: (context) => \"person\" in (grammar[context.recResult] || {}),\r\n                            actions: assign((context) => { return { person: grammar[context.recResult].person } }),\r\n                            target: \"day\"},\r\n                            { target: \".nomatch\"}],\r\n                        MAXSPEECH: [\r\n                            {\r\n                                actions: assign((context) => { return { counts: context.counts ? context.counts+1 : 1 } }),\r\n                                cond: (context) => !context.counts || context.counts < 3,\r\n                                target: \".timeoutnomatch\"\r\n                            },  \r\n                            {   actions: assign((context) => { return { counts: 0 } }),\r\n                            cond: (context) => context.counts >= 3,target: \"maxtimeout\"\r\n                            }\r\n                        ]\r\n                    },   \r\n                        \r\n                    states: {\r\n                        prompt: {\r\n                            entry: say(\"Who are you meeting with?\"),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        ask: {\r\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 5000, id: \"timeout\" })]\r\n                        },\r\n                        nomatch: {\r\n                            entry: say(\"Sorry Would you please tell me, who you are meeting with?\"),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n\r\n                        timeoutnomatch: {\r\n                            entry: say(\"Sorry I could not get any answer from you. I'll repeat! Would you please tell me, who you are meeting with?\"),\r\n                            on: {\r\n                                ENDSPEECH: \"ask\",\r\n                            },\r\n                        },\r\n\r\n                    }\r\n                },\r\n                day: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [\r\n                            { target: \"#root.dm.help\",cond: (context) => context.recResult === 'help'},\r\n                            {cond: (context) => \"day\" in (grammar[context.recResult] || {}),\r\n                            actions: assign((context) => { return { day: grammar[context.recResult].day } }),\r\n                            target: \"wholeday\"},\r\n                            { target: \".nomatch\" }],\r\n\r\n                        MAXSPEECH: [\r\n                            {\r\n                                actions: assign((context) => { return { counts: context.counts ? context.counts+1 : 1 } }),\r\n                                cond: (context) => !context.counts || context.counts < 3,\r\n                                target: \".timeoutnomatch\"\r\n                            },  \r\n                            {   actions: assign((context) => { return { counts: 0 } }),\r\n                                cond: (context) => context.counts >= 3, target: \"maxtimeout\"\r\n                            }\r\n                        ]\r\n                    },\r\n                    states: {\r\n                        prompt: {\r\n                            entry: send((context) => ({\r\n                                type: \"SPEAK\",\r\n                                value: `OK. ${context.person}. On which day is your meeting?`\r\n                            })),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        ask: {\r\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 5000, id: \"timeout\" })]\r\n                        },\r\n                        nomatch: {\r\n                            entry: say(\"Sorry Would you please indicate a suitable day ? \"),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        timeoutnomatch: {\r\n                            entry: say(\"Sorry I could not get any answer from you. I'll repeat!\"),\r\n                            on: {\r\n                                ENDSPEECH: \"ask\",\r\n                            },\r\n                        },\r\n                    }\r\n                },\r\n\r\n\r\n                wholeday: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [\r\n                            { target: \"#root.dm.help\",cond: (context) => context.recResult === 'help'},\r\n                        {\r\n                            cond: (context) => BooleanGrammar[context.recResult].clarity === true,\r\n                            actions: assign((context) => { return { clarity: BooleanGrammar[context.recResult].clarity } }),\r\n                            target: \"wholeday_is_confirmed\"\r\n\r\n                        },\r\n                        {\r\n                            cond: (context) => BooleanGrammar[context.recResult].clarity === false,\r\n                            actions: assign((context) => { return { clarity: BooleanGrammar[context.recResult].clarity } }),\r\n                            target: \"Determination_time\"\r\n\r\n                        },\r\n                        { target: \".nomatch\" }],\r\n                        MAXSPEECH: [\r\n                            {\r\n                                actions: assign((context) => { return { counts: context.counts ? context.counts+1 : 1 } }),\r\n                                cond: (context) => !context.counts || context.counts < 3,\r\n                                target: \".timeoutnomatch\"\r\n                            },  \r\n                            {\r\n                                actions: assign((context) => { return { counts: 0 } }), cond: (context) => context.counts >= 3, target: \"maxtimeout\"\r\n                            }\r\n                        ]\r\n                    },\r\n                    states: {\r\n                        prompt: {\r\n                            entry: send((context) => ({\r\n                                type: \"SPEAK\",\r\n                                value: `OK. ${context.day}. Will it take the whole day?`\r\n                            })),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        ask: {\r\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 5000, id: \"timeout\" })]\r\n                        },\r\n                        nomatch: {\r\n                            entry: say(\"Sorry I didn't catch what you said, would you please say that Will it take the whole day? \"),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        timeoutnomatch: {\r\n                            entry: say(\"Sorry I could not get any answer from you. I'll repeat!\"),\r\n                            on: {\r\n                                ENDSPEECH: \"ask\",\r\n                            },\r\n                        },\r\n                    }\r\n                },\r\n\r\n\r\n                wholeday_is_confirmed: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [{ target: \"#root.dm.help\",cond: (context) => context.recResult === 'help'},\r\n                        {\r\n                            cond: (context) => BooleanGrammar[context.recResult].clarity === true,\r\n                            actions: assign((context) => { return { clarity: BooleanGrammar[context.recResult].clarity } }),\r\n                            target: \"create_appointment\"\r\n\r\n                        },\r\n                        {\r\n                            cond: (context) => BooleanGrammar[context.recResult].clarity === false,\r\n                            actions: assign((context) => { return { clarity: BooleanGrammar[context.recResult].clarity } }),\r\n                            target: \"who\"\r\n\r\n                        },\r\n                        { target: \".nomatch\" }],\r\n                        MAXSPEECH: [\r\n                            {\r\n                                actions: assign((context) => { return { counts: context.counts ? context.counts+1 : 1 } }),\r\n                                cond: (context) => !context.counts || context.counts < 3,\r\n                                target: \".timeoutnomatch\"\r\n                            },  \r\n                            {\r\n                                actions: assign((context) => { return { counts: 0 } }), cond: (context) => context.counts >= 3, target: \"maxtimeout\"\r\n                            }\r\n                        ]\r\n                    },\r\n                    states: {\r\n                        prompt: {\r\n                            entry: send((context) => ({\r\n                                type: \"SPEAK\",\r\n                                value: `OK. Do you want me to create an appointment with ${context.person} on ${context.day} for the whole day?`\r\n                            })),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        ask: {\r\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 5000, id: \"timeout\" })]\r\n                        },\r\n                        nomatch: {\r\n                            entry: send((context) => ({\r\n                                type: \"SPEAK\",\r\n                                value: `Sorry,could you please tell me thet, Do you want me to create an appointment with ${context.person} on ${context.day} for the whole day?`\r\n                            })),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        timeoutnomatch: {\r\n                            entry: say(\"Sorry I could not get any answer from you. I'll repeat!\"),\r\n                            on: {\r\n                                ENDSPEECH: \"ask\",\r\n                            },\r\n                        },\r\n                    }\r\n                },\r\n\r\n                Determination_time: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [ \r\n                            { target: \"#root.dm.help\",cond: (context) => context.recResult === 'help'},\r\n                        {\r\n                            cond: (context) => \"time\" in (grammar[context.recResult] || {}),\r\n                            actions: assign((context) => { return { time: grammar[context.recResult].time } }),\r\n                            target: \"confirm_time\"\r\n\r\n                        },\r\n                        { target: \".nomatch\" }],\r\n                        MAXSPEECH: [\r\n                            {\r\n                                actions: assign((context) => { return { counts: context.counts ? context.counts+1 : 1 } }),\r\n                                cond: (context) => !context.counts || context.counts < 3,\r\n                                target: \".timeoutnomatch\"\r\n                            },  \r\n                            {\r\n                                actions: assign((context) => { return { counts: 0 } }), cond: (context) => context.counts >= 3, target: \"maxtimeout\"\r\n                            }\r\n                        ]\r\n                        \r\n                    },\r\n                    states: {\r\n                        prompt: {\r\n                            entry: say(\"Ok. The meeting is not the whole day.What time is your meeting?\"),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        ask: {\r\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 5000, id: \"timeout\" })]\r\n                        },\r\n                        nomatch: {\r\n                            entry: say(\"Sorry Would you please indicate a suitable time ?\"),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        timeoutnomatch: {\r\n                            entry: say(\"Sorry I could not get any answer from you. I'll repeat!\"),\r\n                            on: {\r\n                                ENDSPEECH: \"ask\",\r\n                            },\r\n                        },\r\n                    }\r\n                },\r\n\r\n                confirm_time: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [{ target: \"#root.dm.help\",cond: (context) => context.recResult === 'help'},\r\n                        {\r\n                            cond: (context) => BooleanGrammar[context.recResult].clarity === true,\r\n                            actions: assign((context) => { return { clarity: BooleanGrammar[context.recResult].clarity } }),\r\n                            target: \"create_appointment\"\r\n\r\n                        },\r\n                        {\r\n                            cond: (context) => BooleanGrammar[context.recResult].clarity === false,\r\n                            actions: assign((context) => { return { clarity: BooleanGrammar[context.recResult].clarity } }),\r\n                            target: \"who\"\r\n\r\n                        },\r\n                        { target: \".nomatch\" }],\r\n                        MAXSPEECH: [\r\n                            {\r\n                                actions: assign((context) => { return { counts: context.counts ? context.counts+1 : 1 } }),\r\n                                cond: (context) => !context.counts || context.counts < 3,\r\n                                target: \".timeoutnomatch\"\r\n                            },  \r\n                            {\r\n                                actions: assign((context) => { return { counts: 0 } }), cond: (context) => context.counts >= 3, target: \"maxtimeout\"\r\n                            }\r\n                        ]\r\n                    },\r\n                    states: {\r\n                        prompt: {\r\n                            entry: send((context) => ({\r\n                                type: \"SPEAK\",\r\n                                value: `OK. Do you want me to create an appointment with ${context.person} on ${context.day} at ${context.time} ?`\r\n                            })),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        ask: {\r\n                            entry: [send('LISTEN'), send('MAXSPEECH', { delay: 5000, id: \"timeout\" })]\r\n                        },\r\n                        nomatch: {\r\n                            entry: send((context) => ({\r\n                                type: \"SPEAK\",\r\n                                value: `Sorry,would you please tell me, Do you want me to create an appointment with ${context.person} on ${context.day} at ${context.time} ?`\r\n                            })),\r\n                            on: { ENDSPEECH: \"ask\" }\r\n                        },\r\n                        timeoutnomatch: {\r\n                            entry: say(\"Sorry I could not get any answer from you. I'll repeat!\"),\r\n                            on: {\r\n                                ENDSPEECH: \"ask\",\r\n                            },\r\n                        },\r\n                    }\r\n                },\r\n\r\n                create_appointment: {\r\n                    initial: \"prompt\",\r\n                    on: { \r\n                        ENDSPEECH: \"init\" },\r\n                    states: {\r\n                        prompt: { entry: say(\"Your appointment has been created\") }\r\n                    }\r\n                },\r\n                maxtimeout: {\r\n                    entry: say(\"Sorry I could not get any answer,maybe we can talk later.have a nice day\"),\r\n                    on: {\r\n                        ENDSPEECH: \"init\",\r\n                    }\r\n                }\r\n            }\r\n\r\n        },\r\n\r\n        help: {\r\n            entry: say(\"I will help you and go back\"),\r\n            on: { ENDSPEECH: \"begin.hist\" }\r\n        }\r\n    \r\n    },\r\n})\r\n\r\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n            \r\n\r\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, send, State, actions } from \"xstate\";\nconst {cancel} = actions;\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMachine } from \"./dmAppointmentPlus\";\n// import { dmMachine } from \"./dmSmartHome\";\n\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\n\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dmMachine\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    }\n                },\n                recognising: {\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: {target:'idle', actions: [cancel('timeout'), assign((context) => { return { counts: 0 } })]},\n                        MAXSPEECH: 'idle'\n                    },\n                    states: {\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive a color command.');\n                listen({\n                    interimResults: false,\n                    continuous: true\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            changeColour: asEffect((context) => {\n                console.log('Repainting...');\n                document.body.style.background = context.recResult;\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda })\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            })\n            /* speak: asEffect((context) => {\n\t     * console.log('Speaking...');\n             *     speak({text: context.ttsAgenda })\n             * } */\n        }\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\n\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://mkappointment.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'http://maraev.me' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n"],"sourceRoot":""}